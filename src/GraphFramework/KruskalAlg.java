/*
CPCS324 Group Project | Phase1 | Section B9B
- Reem Saleh Almalki            2005439
- Roaa Hatim Altunsi            1914946
- Shahad Maher Magram           2010332
- Seham Khaldoun Nahlawi        1915762
 */

package GraphFramework;

import java.util.ArrayList;
import java.util.Collections;

public class KruskalAlg extends MSTAlgorithm{
    
    public KruskalAlg(Graph graph){
        super(graph);
    }
    
    @Override
    public void displayResultingMST(){
        
        
        // Sort edges
        ArrayList<Edge> edges = new ArrayList<>();
        for(int i=0; i < graph.getVerticesNO(); i++){
            edges.addAll(graph.getVertices()[i].getAdjList());
        }
        Collections.sort(edges, (edge1, edge2) -> edge1.getWeight() - edge2.getWeight());
        
        
        int cost = 0, ecounter = 0;
        
        // Kruskal algorithm
        Vertex[] vertexList = new Vertex[graph.getVerticesNO()];
        makeSet(vertexList);
        while(ecounter < graph.getVerticesNO()-1) {
            Edge edge = edges.remove(edges.size()-1);
            
            // Check if the endpoints belong to different sets
            Integer sourceLabel = Integer.valueOf(edge.getSource().getLabel());
            Integer targetLabel = Integer.valueOf(edge.getTarget().getLabel());
            
            if(vertexList[sourceLabel].getLabel() != vertexList[targetLabel].getLabel()){
                // Add the edge to MST and update the labels of the vertices
                MSTResultList.add(ecounter, edge);
                union(vertexList, edge.getSource(), edge.getTarget());
                cost += MSTResultList.get(ecounter).getWeight();
                ecounter++;
            }
        }
        
        // Display the MST and its total cost
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows: ");
        for(Edge edge : MSTResultList){
            edge.displayInfo();
        }
        System.out.println("The cost of designed phone network: " + cost);
    }
    
    // Make set function
    private static void makeSet(Vertex[] list){
        // Initialize the vertex list with labels from 0 to n-1
        for(int i=0; i < list.length; i++) {
    		Vertex ver = new Vertex(Integer.toString(i));
    		list[i] = ver;
    	}
    }
    
    
    // Union Function
    private static void union(Vertex[] vertexList, Vertex vSource, Vertex vTarget){

        Integer sourceLabel = Integer.valueOf(vSource.getLabel());
        Integer targetLabel = Integer.valueOf(vTarget.getLabel());
        
        int labelSource = Integer.parseInt(vertexList[sourceLabel].getLabel());
        int labelTarget = Integer.parseInt(vertexList[targetLabel].getLabel());
        // Update the labels of the vertices to merge two disjoint sets
        for(int i=0; i < vertexList.length; i++) {
            if(Integer.parseInt(vertexList[i].getLabel()) == labelSource){
                vertexList[i].setLabel(""+labelTarget);
            }
        }
    }
}
