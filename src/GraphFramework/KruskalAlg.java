/*
CPCS324 Group Project | Phase1 | Section B9B
- Reem Saleh Almalki            2005439
- Roaa Hatim Altunsi            1914946
- Shahad Maher Magram           2010332
- Seham Khaldoun Nahlawi        1915762
 */

package GraphFramework;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

public class KruskalAlg extends MSTAlgorithm {
    
    // CONSTRUCTOR
    public KruskalAlg(Graph graph){
        super(graph);
    }
    
    // METHODS
    @Override
    public void displayResultingMST(){
        
        // Sort edges
        ArrayList<Edge> edges = new ArrayList<>();
        for(int i=0; i < graph.verticesNo; i++){
            edges.addAll(graph.vertices[i].adjList);
        }
        Collections.sort(edges, (edge1, edge2) -> edge1.weight - edge2.weight);

        // Initialize variables
        int cost = 0, ecounter = 0;
        ArrayList<HashSet<Vertex>> vertexlist = new ArrayList<>();
        makeSet(vertexlist, graph);

        // Iterate through edges
        int i = 0;
        while(ecounter < graph.verticesNo-1)  {
            Edge edge = edges.get(i);
            int source = find(vertexlist, edge.source);
            int target = find(vertexlist, edge.target);
            
            // Check if vertices belong to different subsets
            if(source != target){
                MSTResultList.add(ecounter,edge); // Add edge to MST
                union(vertexlist, source, target); // Merge subsets
                cost += MSTResultList.get(ecounter).weight; // Update cost of MST
                ecounter++;
            }
            i++;
        }
        
        // Display the MST and its total cost
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows: ");
        for(Edge edge : MSTResultList){
            edge.displayInfo();
        }
        System.out.println("The cost of designed phone network: " + cost);
    }

    // Make Set function
    private static void makeSet(ArrayList<HashSet<Vertex>> vertexlist, Graph graph){
        for(int i = 0; i < graph.verticesNo; i++){
            HashSet<Vertex> list = new HashSet<>();
            list.add(graph.vertices[i]);
            vertexlist.add(list);
    	}   
    }

    // Find Function
    private static int find(ArrayList<HashSet<Vertex>> vertexlist, Vertex vertex){
        int num = -1;
        for (int i = 0; i < vertexlist.size(); i++) {
            HashSet<Vertex> verlist = vertexlist.get(i);
            for (Vertex ver : verlist) {
                if (ver.label.equals(vertex.label)) { // Check if vertex exists in subset
                    num = i;
                    return num;
                }
            }
        }
        return num;
    }
    
    // Union Function
    private static void union(ArrayList<HashSet<Vertex>> vertexlist, int sublist1, int sublist2){
        HashSet<Vertex> list1 = vertexlist.get(sublist1);
        HashSet<Vertex> list2 = vertexlist.get(sublist2);
        for (Vertex sub2 : list2) {
            list1.add(sub2); // Merge subsets
        }
        vertexlist.remove(sublist2); // Remove merged subset
    }
}
