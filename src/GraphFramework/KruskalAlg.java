/*
CPCS324 Group Project | Phase1 | Section B9B
- Reem Saleh Almalki            2005439
- Roaa Hatim Altunsi            1914946
- Shahad Maher Magram           2010332
- Seham Khaldoun Nahlawi        1915762
 */

package GraphFramework;

import java.util.ArrayList;
import java.util.Collections;

public class KruskalAlg extends MSTAlgorithm{
    
    public KruskalAlg(Graph graph){
        super(graph);
    }
    
    @Override
    public void displayResultingMST(){
        
        
        // Sort edges
        ArrayList<Edge> edges = new ArrayList<>();
        for(int i=0; i < graph.verticesNo; i++){
            edges.addAll(graph.vertices[i].adjList);
        }
        Collections.sort(edges, (edge1, edge2) -> edge1.weight - edge2.weight);
        
        
        int cost = 0, ecounter = 0;
        
        // Kruskal algorithm
        Vertex[] vertexList = new Vertex[graph.verticesNo];
        makeSet(vertexList);
        while(ecounter < graph.verticesNo-1) {
            Edge edge = edges.remove(edges.size()-1);
            
            // Check if the endpoints belong to different sets
            Integer sourceLabel = Integer.valueOf(edge.source.label);
            Integer targetLabel = Integer.valueOf(edge.source.label);
            
            if(vertexList[sourceLabel].label != vertexList[targetLabel].label){
                // Add the edge to MST and update the labels of the vertices
                MSTResultList.add(ecounter, edge);
                union(vertexList, edge.source, edge.source);
                cost += MSTResultList.get(ecounter).weight;
                ecounter++;
            }
        }
        
        // Display the MST and its total cost
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows: ");
        for(Edge edge : MSTResultList){
            edge.displayInfo();
        }
        System.out.println("The cost of designed phone network: " + cost);
    }
    
    // Make set function
    private static void makeSet(Vertex[] list){
        // Initialize the vertex list with labels from 0 to n-1
        for(int i=0; i < list.length; i++) {
    		Vertex ver = new Vertex(Integer.toString(i));
    		list[i] = ver;
    	}
    }
    
    
    // Union Function
    private static void union(Vertex[] vertexList, Vertex vSource, Vertex vTarget){

        Integer sourceLabel = Integer.valueOf(vSource.label);
        Integer targetLabel = Integer.valueOf(vTarget.label);
        
        int labelSource = Integer.parseInt(vertexList[sourceLabel].label);
        int labelTarget = Integer.parseInt(vertexList[targetLabel].label);
        // Update the labels of the vertices to merge two disjoint sets
        for(int i=0; i < vertexList.length; i++) {
            if(Integer.parseInt(vertexList[i].label) == labelSource){
                vertexList[i].label = ""+labelTarget;
            }
        }
    }
}
